---
title: "Readings in Database Systems 4. Новые архитектуры СУБД"
date: 2020-08-21T17:52:07+03:00
summary: "Вероятно, самое важное, что произошло в среде СУБД, - это смерть
подхода «всех под одну гребенку». До начала 2000-х годов традиционная дисковая
архитектура с построчным хранением была повсеместной. Фактически, у коммерческих
продавцов был молоток, и всё было гвоздем. За последние пятнадцать лет произошло
несколько серьезных потрясений, которые мы обсудим по очереди."
categories:
- readings in database systems
- red book
- oltp
- column store
- row store
- two-phase locking
- Michael Stonebraker
---

> Избранные статьи:
> 
> - Mike Stonebraker, Daniel J. Abadi, Adam Batkin, Xuedong Chen, Mitch
>   Cherniack, Miguel Ferreira, Edmond Lau, Amerson Lin, Sam Madden,
>   Elizabeth O’Neil, Pat O’Neil, Alex Rasin, Nga Tran, Stan Zdonik. C-store:
>   A Column-oriented DBMS. SIGMOD, 2005.
>
> - Cristian Diaconu, Craig Freedman, Erik Ismert, Per-Ake Larson, Pravin Mittal,
>   Ryan Stonecipher, Nitin Verma, Mike Zwilling. Hekaton: SQL Server’s
>   Memory-optimized OLTP Engine. SIGMOD, 2013.
>
> - Stavros Harizopoulos, Daniel J. Abadi, Samuel Madden, Michael Stonebraker.
>   OLTP Through the Looking Glass, and What We Found There. SIGMOD, 2008.
>
> Автор: Michael Stonebraker

{{< param Summary >}}

Во-первых, сообщество осознало, что поколоночное хранение значительно превосходит
построчное хранение на рынке хранилищ данных. Хранилища данных быстро нашли
применение в розничных сетях, ориентированных на клиентов, и быстро
распространились на данные, ориентированные на клиентов в целом. В хранилищах
записана историческая информация о транзакциях клиентов. По сути, это
«кто-что-почему-когда-где» каждого взаимодействия с клиентом.

Принято считать, что хранилище данных строится вокруг центральной таблицы
фактов, в которой записывается эта транзакционная информация. Вокруг неё
находятся таблицы измерений, в которых записывается информация, которая может
быть извлечена из таблицы фактов. В сценарии розничной торговли есть таблицы
измерений для магазинов, клиентов, продуктов и времени. Результатом является так
называемая звездная схема [^96]. Если магазины сгруппированы по регионам, то
может быть несколько уровней таблиц измерений, и в результате получится схема
«снежинка».

Ключевое наблюдение состоит в том, что таблицы фактов обычно «толстые» и часто
содержат сотню или более атрибутов. Очевидно, они также «длинные», так как
необходимо записать очень много фактов. Как правило, запросы к хранилищу данных
представляют собой сочетание повторяющихся запросов (создание ежемесячного
отчета о продажах по магазинам) и «специальных» (ad hoc) запросов. Например, на
розничном складе можно узнать, что продается на северо-востоке во время снежной
бури, а что продается на побережье Атлантического океана во время ураганов.

Более того, никто не запускает запрос `select *` для получения всех строк в
таблице фактов. Вместо этого указывают агрегат, который извлекает полдюжины
атрибутов из 100 в таблице. Следующий запрос получает другой набор, и среди
критериев фильтрации практически отсутствует локальность.

В этом случае очевидно, что поколоночное хранилище переместит с диска в основную
память в 16 раз меньше данных, чем построчное хранилище (6 столбцов против 100).
Следовательно, у него есть несправедливое преимущество. Более того, рассмотрим
блок хранения. В поколоночном хранилище в этом блоке будет один атрибут, тогда
как в построчном хранилище будет 100. Очевидно, что сжатие будет работать лучше
для одного атрибута, чем для 100. Кроме того, построчные хранилища хранят
заголовок для каждой записи (в SQLServer это, вероятно, 16 байт). Напротив,
поколоночные хранилища стараются не иметь такого заголовка.

Наконец, построчный исполнитель имеет внутренний цикл, посредством которого
запись валидируется на выходе. Следовательно, накладные расходы внутреннего
цикла, которые являются значительными, приходятся на каждую проверяемую запись.
Напротив, основная операция поколоночного хранилища состоит в том, чтобы извлечь
столбец и выбрать подходящие элементы. Таким образом, накладные расходы
внутреннего цикла возникают лишь один раз для каждого провереннего столбца,
а не на каждую проверяемую строку. Таким образом, поколоночный исполнитель более
эффективен в использовании процессора и извлекает с диска меньше данных. В
большинстве реальных сред поколоночные хранилища в 50–100 раз быстрее, чем
построчные хранилища.

Ранние колоночные хранилища включали Sybase IQ [^108], появившуюся в 1990-х, и
MonetDB [^30]. Однако эта технология восходит к 1970-м годам [^25] [^104].
В 2000-х годах C-Store/Vertica появился как хорошо финансируемый стартап с
высокопроизводительной реализацией. В течение следующего десятилетия весь рынок
хранилищ данных превратился из мира построчных хранилищ в мир колоночных хранилищ.
Возможно, Sybase IQ могла бы сделать то же самое несколько раньше, если бы
Sybase более активно инвестировала в технологию и реализовывала многоузловую
реализацию. Преимущества поколоночного исполнителя убедительно обсуждается в
[^30], хотя он и трудно читается.

Вторым серьезным изменением стало резкое падение цен на основные модули памяти.
В настоящее время можно купить 1 терабайт примерно за 25 000 долларов, а
высокопроизводительный вычислительный кластер с несколькими терабайтами можно
купить за 100 000 долларов. Ключевой вывод заключается в том, что базы данных
OLTP не такие уж и большие. Один терабайт - это очень большая OLTP база данных,
которая является кандидатом на развертывание основной памяти. Как отмечено в
статье «OLTP Through the Looking Glass, and What We Found There», нежелательно
запускать дисковое хранилище строк, когда данные помещаются в основную память,
накладные расходы слишком высоки.

Фактически, рынок OLTP теперь становится основным рынком СУБД с памятью. Опять
же, традиционные дисковые строчные хранилища просто неконкурентоспособны. Для
хорошей работы необходимы новые решения для управления параллелизмом,
восстановления после сбоев и многопоточности, и я ожидаю, что в ближайшие
несколько лет архитектуры OLTP будут развиваться.

На данный момент я предполагаю, что никто не будет использовать традиционную
двухфазную блокировку (2PL). Скорее всего, будут преобладать методы, основанные
на упорядочивании меток времени или нескольких версиях. В третьей статье этого
раздела обсуждается Hekaton, реализующий современную схему MVCC.

Также необходимо иметь дело с восстановлением после сбоя. В общем, предлагаемое
решение - это репликация и аварийное переключение в режиме онлайн, которое было
впервые предложено компанией Tandem два десятилетия назад. Традиционно
считается, что нужно писать журнал, передавать его по сети, а затем  повторять
транзакций на резервном сервере. В [^111] было показано, что эта
активно-пассивная архитектура в 3 раза уступает схеме актив-актив, где
транзакции просто выполняются на каждой реплике. Если выполняется схема
«активный-активный», необходимо обеспечить выполнение транзакций в одном и том
же порядке на каждой реплике. К сожалению, MVCC этого не делает. Это привело к
интересу к детерминированным схемам управления параллелизмом, которые, вероятно,
будут намного быстрее в сквозной системе, чем MVCC.

В любом случае OLTP движется к развертыванию в основной памяти, и для поддержки
этого варианта использования развертывается новый класс СУБД в основной памяти.

Третье развернувшееся явление - движение «no SQL». По сути, существует около 100
СУБД, которые поддерживают различные модели данных и имеют следующие две
характеристики:

- Подход «Из коробки». Программисту легко приступить к работе и сделать что-то
  рабочее. РСУБД, напротив, очень тяжелы и требуют заранее созданной схемы.
- Поддержка полуструктурированных данных. Каждая запись может содержать
  различные наборы атрибутов. В традиционных СУБД такой подход повлечет таблицы
  с большим количеством колонок (широкий кортеж), которые при этом будут сильно
  разражены. Следовательно, это будет крайне неэфективно.

Это тревожный сигнал для коммерческих поставщиков, которые хотят сделать системы
более простыми в использовании и поддерживать полуструктурированные типы данных,
такие как JSON. В целом, я ожидаю, что рынок No SQL со временем сольется с
рынком SQL, поскольку СУБД реагируют на два упомянутых выше момента. 

Четвертое важное изменение - это появление среды Hadoop / HDFS / Spark, которая
обсуждается в главе 6.



[^25]: D. S. Batory. On searching transposed files. ACM Transactions on Database
Systems (TODS), 4(4), Dec. 1979.

[^30]: P. A. Boncz, M. Zukowski, and N. Nes. Monetdb/x100: Hyper-pipelining
query execution. In CIDR, 2005.

[^96]: R. Kimball and M. Ross. The data warehouse toolkit: the complete guide to
dimensional modeling. John Wiley & Sons, 2011.

[^104]: R. Lorie and A. Symonds. A relational access method for interactive
applications. Courant Computer Science Symposia, Vol. 6: Data Base Systems, 1971.

[^108]: R. MacNicol and B. French. Sybase iq multiplex-designed for analytics.
In VLDB, 2004.

[^111]: N. Malviya, A. Weisberg, S. Madden, and M. Stonebraker. Rethinking main
memory OLTP recovery. In ICDE, 2014.
